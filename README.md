### **1. Сортировка выбором (Selection Sort)**

**Определение:** Алгоритм сортировки, который на каждом шаге находит минимальный элемент в неотсортированной части массива и помещает его в конец отсортированной части.

**Принцип работы:** Поиск минимального элемента в неотсортированной части и обмен его с первым элементом этой части.

**Пошаговый процесс с примером:**
Массив: [64, 25, 12, 22, 11]

**Шаг 1:** Находим min = 11, меняем с arr[0]
[**11**, 25, 12, 22, 64]

**Шаг 2:** Находим min = 12, меняем с arr[1]
[11, **12**, 25, 22, 64]

**Шаг 3:** Находим min = 22, меняем с arr[2]
[11, 12, **22**, 25, 64]

**Шаг 4:** Находим min = 25, меняем с arr[3]
[11, 12, 22, **25**, 64]

**Методы и функции:**
- Вложенные циклы for
- Поиск минимального элемента
- Обмен элементов (swap)

**Временная сложность:** O(n²)

**Почему такая временная сложность:**
- Количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ n²/2
- Количество обменов: n-1
- Всегда выполняется одинаковое количество операций независимо от входных данных

---

### **2. Сортировка обменом (Bubble Sort)**

**Определение:** Алгоритм сортировки, многократно проходящий по массиву и сравнивающий соседние элементы.

**Принцип работы:** Попарное сравнение и обмен соседних элементов до полной сортировки.

**Пошаговый процесс с примером:**
Массив: [5, 1, 4, 2, 8]

**Проход 1:**
[1, 5, 4, 2, 8] → 1<5
[1, 4, 5, 2, 8] → 4<5
[1, 4, 2, 5, 8] → 2<5
[1, 4, 2, 5, 8] → 5<8

**Проход 2:**
[1, 4, 2, 5, 8] → 1<4
[1, 2, 4, 5, 8] → 2<4
[1, 2, 4, 5, 8] → 4<5
[1, 2, 4, 5, 8] → 5<8

**Методы и функции:**
- Вложенные циклы for
- Сравнение соседних элементов
- Обмен элементов

**Временная сложность:** O(n²)

**Почему такая временная сложность:**
- В худшем случае: n(n-1)/2 сравнений
- В лучшем случае (с оптимизацией): O(n)
- Среднее количество операций пропорционально n²

---

### **3. Сортировка вставками (Insertion Sort)**

**Определение:** Алгоритм, который строит отсортированный массив по одному элементу за раз.

**Принцип работы:** Вставка каждого нового элемента в правильную позицию в отсортированной части.

**Пошаговый процесс с примером:**
Массив: [12, 11, 13, 5, 6]

**Шаг 1:** [12] (отсортирован)
**Шаг 2:** [11, 12] (вставили 11)
**Шаг 3:** [11, 12, 13] (вставили 13)
**Шаг 4:** [5, 11, 12, 13] (вставили 5)
**Шаг 5:** [5, 6, 11, 12, 13] (вставили 6)

**Методы и функции:**
- Внешний цикл for
- Внутренний цикл while
- Сдвиг элементов
- Вставка элемента

**Временная сложность:** O(n²)

**Почему такая временная сложность:**
- В худшем случае: n(n-1)/2 сравнений и сдвигов
- В лучшем случае: O(n) сравнений
- Средняя сложность O(n²) для случайных данных

---

### **4. Сортировка слиянием (Merge Sort)**

**Определение:** Алгоритм сортировки, использующий стратегию "разделяй и властвуй".

**Принцип работы:** Рекурсивное разделение массива и слияние отсортированных частей.

**Пошаговый процесс с примером:**
Массив: [38, 27, 43, 3, 9, 82, 10]

**Разделение:**
[38, 27, 43, 3] и [9, 82, 10]
[38, 27] и [43, 3] | [9, 82] и [10]
[38] и [27] | [43] и [3] | [9] и [82] | [10]

**Слияние:**
[27, 38] и [3, 43] | [9, 82] и [10]
[3, 27, 38, 43] и [9, 10, 82]
[3, 9, 10, 27, 38, 43, 82]

**Методы и функции:**
- Рекурсия
- Разделение массива
- Слияние отсортированных массивов
- Вспомогательные массивы

**Временная сложность:** O(n log n)

**Почему такая временная сложность:**
- Глубина рекурсии: log₂n
- На каждом уровне: O(n) операций слияния
- Общее время: n × log n

---

### **5. Сортировка Шелла (Shellsort)**

**Определение:** Усовершенствование сортировки вставками с убывающими шагами.

**Принцип работы:** Сортировка подмассивов элементов, отстоящих на определенном расстоянии.

**Пошаговый процесс с примером:**
Массив: [12, 34, 54, 2, 3], шаги: 2, 1

**Шаг 2:** Сортируем подмассивы с gap=2
[12, 2, 3, 34, 54] → [2, 12, 3, 34, 54]

**Шаг 1:** Сортируем подмассивы с gap=1
[2, 3, 12, 34, 54]

**Методы и функции:**
- Последовательность шагов (gap)
- Модифицированная сортировка вставками
- Вложенные циклы

**Временная сложность:** O(n log n) - O(n²)

**Почему такая временная сложность:**
- Зависит от последовательности шагов
- Для хороших последовательностей: O(n log n)
- Для плохих последовательностей: O(n²)

---

### **6. Быстрая сортировка (Quick Sort)**

**Определение:** Алгоритм с выбором опорного элемента и разделением массива.

**Принцип работы:** Разделение массива относительно опорного элемента и рекурсивная сортировка частей.

**Пошаговый процесс с примером:**
Массив: [10, 7, 8, 9, 1, 5], опорный: 5

**Разделение:**
[1, 5, 8, 9, 10, 7] → элементы <5: [1], >5: [8, 9, 10, 7]

**Рекурсия:**
Сортируем [1] и [7, 8, 9, 10]
Результат: [1, 5, 7, 8, 9, 10]

**Методы и функции:**
- Рекурсия
- Выбор опорного элемента
- Разделение (partition)
- Обмен элементов

**Временная сложность:** O(n log n) в среднем, O(n²) в худшем случае

**Почему такая временная сложность:**
- Средний случай: T(n) = 2T(n/2) + O(n) → O(n log n)
- Худший случай: T(n) = T(n-1) + O(n) → O(n²)

---

### **7. Пирамидальная сортировка (Heap Sort)**

**Определение:** Алгоритм сортировки, использующий структуру данных "куча".

**Принцип работы:** Построение max-кучи и последовательное извлечение максимальных элементов.

**Пошаговый процесс с примером:**
Массив: [4, 10, 3, 5, 1]

**Построение кучи:**
[10, 5, 3, 4, 1]

**Извлечение:**
[5, 4, 3, 1, 10]
[4, 1, 3, 5, 10]
[3, 1, 4, 5, 10]
[1, 3, 4, 5, 10]

**Методы и функции:**
- Построение кучи (heapify)
- Извлечение корня
- Перестроение кучи
- Обмен элементов

**Временная сложность:** O(n log n)

**Почему такая временная сложность:**
- Построение кучи: O(n)
- n извлечений по O(log n) каждое: O(n log n)
- Общее время: O(n log n)

---

### **8. Последовательный поиск (Linear Search)**

**Определение:** Простейший алгоритм поиска проверкой каждого элемента.

**Принцип работы:** Последовательная проверка элементов от начала до конца массива.

**Пошаговый процесс с примером:**
Массив: [2, 4, 0, 1, 9], target = 1

**Шаг 1:** 2 ≠ 1
**Шаг 2:** 4 ≠ 1
**Шаг 3:** 0 ≠ 1
**Шаг 4:** 1 = 1 → найден на позиции 3

**Методы и функции:**
- Цикл for
- Сравнение элементов
- Возврат индекса

**Временная сложность:** O(n)

**Почему такая временная сложность:**
- В худшем случае: n сравнений
- В среднем случае: n/2 сравнений
- В лучшем случае: 1 сравнение

---

### **9. Бинарный поиск (Binary Search)**

**Определение:** Алгоритм поиска в отсортированном массиве делением области поиска пополам.

**Принцип работы:** Поиск путем многократного деления отсортированного массива пополам.

**Пошаговый процесс с примером:**
Массив: [2, 3, 4, 10, 40], target = 10

**Шаг 1:** mid = 4, 4 < 10 → ищем справа
**Шаг 2:** mid = 10, 10 = 10 → найден

**Методы и функции:**
- Итеративный или рекурсивный подход
- Вычисление середины
- Сравнение с целевым значением
- Сужение области поиска

**Временная сложность:** O(log n)

**Почему такая временная сложность:**
- На каждом шаге область поиска уменьшается вдвое
- Максимальное количество шагов: log₂n
- Быстрое уменьшение размера задачи

---

### **10. Интерполирующий поиск (Interpolation Search)**

**Определение:** Алгоритм поиска с предсказанием позиции на основе значений.

**Принцип работы:** Использование линейной интерполяции для оценки позиции искомого элемента.

**Пошаговый процесс с примером:**
Массив: [10, 20, 30, 40, 50], target = 40

**Формула:** pos = lo + [(x - arr[lo]) × (hi - lo) / (arr[hi] - arr[lo])]
pos = 0 + [(40-10) × (4-0) / (50-10)] = 0 + (30×4/40) = 3

**Методы и функции:**
- Линейная интерполяция
- Рекурсивный поиск
- Вычисление позиции
- Сравнение элементов

**Временная сложность:** O(log log n) в среднем, O(n) в худшем случае

**Почему такая временная сложность:**
- При равномерном распределении: O(log log n)
- При неравномерном распределении: O(n)
- Зависит от распределения данных

---

### **11. Поиск по Фибоначчи (Fibonacci Search)**

**Определение:** Алгоритм поиска с использованием чисел Фибоначчи для определения точек разделения.

**Принцип работы:** Деление массива в пропорциях, определяемых числами Фибоначчи.

**Пошаговый процесс с примером:**
Массив: [10, 22, 35, 40, 45, 50, 80, 82], target = 45

**Числа Фибоначчи:** 0, 1, 1, 2, 3, 5, 8, 13
**Шаг 1:** F[6] = 8, сравниваем arr[7] = 82 > 45
**Шаг 2:** F[5] = 5, сравниваем arr[4] = 45 = 45 → найден

**Методы и функции:**
- Генерация чисел Фибоначчи
- Определение точек сравнения
- Сравнение элементов
- Сужение области поиска

**Временная сложность:** O(log n)

**Почему такая временная сложность:**
- Деление массива в золотом сечении
- Количество шагов: logᵩn ≈ 1.44 log₂n
- Асимптотически эквивалентен O(log n)

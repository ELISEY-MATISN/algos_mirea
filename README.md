1. Сортировка выбором (Selection Sort)
Определение: Алгоритм сортировки, который на каждом шаге находит минимальный элемент в неотсортированной части массива и помещает его в конец отсортированной части.

Принцип работы:
Массив делится на отсортированную (слева) и неотсортированную (справа) части
На каждом шаге находится минимальный элемент в неотсортированной части
Найденный минимальный элемент меняется местами с первым элементом неотсортированной части
Граница отсортированной части сдвигается на один элемент вправо

Анализ метода:
Не адаптивный - работает одинаково на любых данных
Количество сравнений постоянно: n(n-1)/2
Количество перестановок: n-1 (минимально среди квадратичных сортировок)

Особенности:
Простая реализация
Не требует дополнительной памяти
Неустойчивая сортировка
Неэффективен на больших массивах

Сложность:
Временная: O(n²) (худший, средний, лучший случаи)
Пространственная: O(1)


2. Сортировка обменом (Bubble Sort)
Определение: Алгоритм сортировки, многократно проходящий по массиву и сравнивающий соседние элементы, "всплывающий" наибольшие элементы в конец.

Принцип работы:
Последовательно сравниваются соседние элементы
Если элементы находятся в неправильном порядке, они меняются местами
После каждого прохода наибольший элемент "всплывает" в свою конечную позицию
Процесс повторяется для оставшейся части массива

Анализ метода:
Адаптивный - может быть оптимизирован для раннего завершения
Эффективен на почти отсортированных массивах
Количество операций сильно зависит от исходного порядка элементов

Особенности:
Очень прост для понимания
Устойчивая сортировка
Можно оптимизировать флагом перестановок
Медлителен на больших массивах

Сложность:
В худшем случае: O(n²)
В лучшем случае: O(n)
Пространственная: O(1)


3. Сортировка вставками (Insertion Sort)
Определение: Алгоритм, который строит отсортированный массив по одному элементу за раз, вставляя каждый новый элемент в правильную позицию.

Принцип работы:
Массив мысленно делится на отсортированную и неотсортированную части
Каждый следующий элемент из неотсортированной части вставляется в отсортированную часть
Для вставки элементы большие вставляемого сдвигаются вправо
Процесс продолжается до полной сортировки массива

Анализ метода:
Адаптивный - эффективен на частично отсортированных данных
Количество операций зависит от степени упорядоченности исходных данных
Эффективен для небольших массивов

Особенности:
Устойчивая сортировка
Работает онлайн - может обрабатывать поступающие данные
Эффективен на маленьких и почти отсортированных массивах
Часто используется как часть более сложных алгоритмов

Сложность:
В худшем случае: O(n²)
В лучшем случае: O(n)
Пространственная: O(1)


4. Сортировка слиянием (Merge Sort)
Определение: Эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй" - рекурсивное разделение и слияние отсортированных частей.

Принцип работы:
Рекурсивно делит массив на две равные части
Сортирует каждую половину рекурсивно
Сливает отсортированные половины в один массив
Процесс продолжается до базового случая (массив из 1 элемента)

Анализ метода:
Гарантированная временная сложность
Требует дополнительной памяти для слияния
Хорошо поддается распараллеливанию
Стабильная производительность на любых данных

Особенности:
Устойчивая сортировка
Гарантированная сложность O(n log n)
Требует O(n) дополнительной памяти
Эффективен для больших массивов

Сложность:
Временная: O(n log n) (все случаи)
Пространственная: O(n)


5. Сортировка Шелла (Shellsort)
Определение: Усовершенствование сортировки вставками, сортирующее элементы на определенных расстояниях друг от друга с постепенным уменьшением шага.

Принцип работы:
Использует последовательность убывающих шагов (gaps)
На каждом шаге сортирует подмассивы элементов, отстоящих на distance друг от друга
Последний шаг всегда равен 1 (обычная сортировка вставками)
Устраняет недостатки сортировки вставками при больших смещениях

Анализ метода:
Сложность зависит от выбора последовательности шагов
Эффективнее простых квадратичных сортировок
Трудно анализировать теоретически
Практически эффективен на средних массивах

Особенности:
Неустойчивая сортировка
Работает на месте
Сложность между O(n log n) и O(n²)
Эффективен для средних массивов

Сложность:
Зависит от последовательности шагов
В лучшем случае: O(n log n)
В худшем случае: O(n²)
Пространственная: O(1)


6. Быстрая сортировка (Quick Sort)
Определение: Эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй" с выбором опорного элемента и разделением массива.

Принцип работы:
Выбирается опорный элемент (pivot)
Массив разделяется на элементы меньше опорного и больше опорного
Рекурсивно применяется к обеим частям
Процесс продолжается до базового случая

Анализ метода:
В среднем самый быстрый на практике
Производительность зависит от выбора опорного элемента
Худший случай редок при правильной реализации
Эффективно использует кэш процессора

Особенности:
Неустойчивая сортировка
В среднем O(n log n), в худшем O(n²)
Работает на месте
Широко используется на практике

Сложность:
В среднем случае: O(n log n)
В худшем случае: O(n²)
Пространственная: O(log n)


7. Пирамидальная сортировка (Heap Sort)
Определение: Алгоритм сортировки, использующий структуру данных "куча" для эффективного извлечения максимальных элементов.

Принцип работы:
Строит из массива max-кучу (бинарное дерево с свойством кучи)
Последовательно извлекает максимальный элемент (корень)
Перестраивает кучу после каждого извлечения
Извлеченные элементы образуют отсортированный массив

Анализ метода:
Гарантированная временная сложность
Всегда работает за O(n log n)
Не требует дополнительной памяти
Медленнее быстрой сортировки на практике

Особенности:
Неустойчивая сортировка
Гарантированная сложность O(n log n)
Работает на месте
Эффективен когда важна предсказуемость

Сложность:
Временная: O(n log n) (все случаи)
Пространственная: O(1)


8. Последовательный поиск (Linear Search)
Определение: Простейший алгоритм поиска, проверяющий каждый элемент последовательно до нахождения искомого.

Принцип работы:
Начинает с первого элемента массива
Последовательно сравнивает каждый элемент с целевым значением
При нахождении совпадения возвращает индекс элемента
При достижении конца массива без нахождения возвращает -1

Анализ метода:
Простейшая реализация
Работает с неотсортированными данными
Гарантирует нахождение элемента если он присутствует
Неэффективен для больших массивов

Особенности:
Работает на неотсортированных массивах
Простая реализация
Гарантированный результат
Медленный на больших данных

Сложность:
Временная: O(n)
Пространственная: O(1)


9. Бинарный поиск (Binary Search)
Определение: Эффективный алгоритм поиска в отсортированном массиве, многократно делящий область поиска пополам.

Принцип работы:
Определяет границы поиска (начало и конец массива)
Вычисляет средний элемент
Сравнивает средний элемент с искомым значением
В зависимости от результата сужает область поиска
Повторяет до нахождения элемента или пустой области

Анализ метода:
Очень эффективен для больших отсортированных массивов
Требует предварительной сортировки данных
Может быть реализован итеративно и рекурсивно
Основа многих алгоритмов поиска

Особенности:
Работает только с отсортированными данными
Очень высокая эффективность
Простая реализация
Широко применяется на практике

Сложность:
Временная: O(log n)
Пространственная: O(1)


10. Интерполирующий поиск (Interpolation Search)
Определение: Улучшенный алгоритм поиска для равномерно распределенных данных, предсказывающий позицию элемента на основе значений.

Принцип работы:
Использует формулу интерполяции для предсказания позиции
Вычисляет вероятное местоположение элемента
Сравнивает элемент в вычисленной позиции с искомым
Рекурсивно сужает область поиска
Эффективен при равномерном распределении данных

Анализ метода:
Очень быстр для равномерно распределенных данных
Может деградировать до линейного поиска
Сложнее в реализации чем бинарный поиск
Эффективен когда данные распределены равномерно

Особенности:
Требует отсортированных данных
Эффективен при равномерном распределении
Сложнее реализации
Меньше сравнений чем у бинарного поиска

Сложность:
В лучшем случае: O(log log n)
В худшем случае: O(n)
Пространственная: O(1)

11. Поиск по Фибоначчи (Fibonacci Search)
Определение: Алгоритм поиска, использующий числа Фибоначчи для определения точек разделения массива.

Принцип работы:
Использует числа Фибоначчи для определения позиций сравнения
Делит массив в пропорциях близких к золотому сечению
Сравнивает элемент в вычисленной позиции с искомым
Сужает область поиска на основе сравнения
Использует только операции сложения и вычитания

Анализ метода:
Сложность аналогична бинарному поиску
Использует только простые арифметические операции
Более сложная реализация
На практике редко превосходит бинарный поиск

Особенности:
Работает на отсортированных данных
Использует числа Фибоначчи
Только операции сложения/вычитания
Сложная реализация

Сложность:
Временная: O(log n)
Пространственная: O(1)

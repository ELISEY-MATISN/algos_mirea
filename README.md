### **1. Сортировка выбором (Selection Sort)**

**Определение:** Алгоритм сортировки, который на каждом шаге находит минимальный элемент в неотсортированной части массива и помещает его в конец отсортированной части.

**Объяснение работы алгоритма:**
- Массив делится на отсортированную (слева) и неотсортированную (справа) части
- На каждом шаге находится минимальный элемент в неотсортированной части
- Найденный минимальный элемент меняется местами с первым элементом неотсортированной части
- Процесс повторяется для оставшейся неотсортированной части

**Временная сложность алгоритма:**
- **Худший случай:** O(n²) - массив отсортирован в обратном порядке
- **Средний случай:** O(n²) - случайный порядок элементов
- **Лучший случай:** O(n²) - массив уже отсортирован
- Всегда выполняется ≈ n²/2 сравнений

---

### **2. Сортировка обменом (Bubble Sort)**

**Определение:** Алгоритм сортировки, многократно проходящий по массиву и сравнивающий соседние элементы, "всплывающий" наибольшие элементы в конец.

**Объяснение работы алгоритма:**
- Последовательно сравниваются соседние элементы массива
- Если элементы находятся в неправильном порядке, они меняются местами
- После каждого прохода самый большой элемент "всплывает" в конец массива
- Процесс повторяется до полной сортировки массива

**Временная сложность алгоритма:**
- **Худший случай:** O(n²) - массив отсортирован в обратном порядке
- **Средний случай:** O(n²) - случайный порядок элементов
- **Лучший случай:** O(n) - массив уже отсортирован (с оптимизацией)

---

### **3. Сортировка вставками (Insertion Sort)**

**Определение:** Алгоритм, который строит отсортированный массив по одному элементу за раз, вставляя каждый новый элемент в правильную позицию.

**Объяснение работы алгоритма:**
- Массив делится на отсортированную и неотсортированную части
- Каждый следующий элемент из неотсортированной части вставляется в отсортированную часть
- Для вставки элементы большие вставляемого сдвигаются вправо
- Процесс продолжается до полной сортировки массива

**Временная сложность алгоритма:**
- **Худший случай:** O(n²) - массив отсортирован в обратном порядке
- **Средний случай:** O(n²) - случайный порядок элементов
- **Лучший случай:** O(n) - массив уже отсортирован

---

### **4. Сортировка слиянием (Merge Sort)**

**Определение:** Эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй" - рекурсивное разделение и слияние отсортированных частей.

**Объяснение работы алгоритма:**
- Рекурсивно делит массив на две равные части
- Сортирует каждую половину рекурсивно
- Сливает отсортированные половины в один массив
- Процесс продолжается до базового случая (массив из 1 элемента)

**Временная сложность алгоритма:**
- **Худший случай:** O(n log n)
- **Средний случай:** O(n log n)
- **Лучший случай:** O(n log n)
- Всегда выполняется ≈ n log n операций

---

### **5. Сортировка Шелла (Shellsort)**

**Определение:** Усовершенствование сортировки вставками, сортирующее элементы на определенных расстояниях друг от друга с постепенным уменьшением шага.

**Объяснение работы алгоритма:**
- Использует последовательность убывающих шагов (gaps)
- На каждом шаге сортирует подмассивы элементов, отстоящих на distance друг от друга
- Последний шаг всегда равен 1 (обычная сортировка вставками)
- Постепенно уменьшает шаг до полной сортировки

**Временная сложность алгоритма:**
- **Зависит от последовательности шагов:**
- **Лучший случай:** O(n log n) - для последовательности Кнута
- **Средний случай:** O(n^1.25) - эмпирически
- **Худший случай:** O(n²) - для плохих последовательностей

---

### **6. Быстрая сортировка (Quick Sort)**

**Определение:** Эффективный алгоритм сортировки, использующий стратегию "разделяй и властвуй" с выбором опорного элемента и разделением массива.

**Объяснение работы алгоритма:**
- Выбирается опорный элемент (pivot)
- Массив разделяется на элементы меньше опорного и больше опорного
- Рекурсивно применяется к обеим частям
- Базовый случай - массив из 0 или 1 элемента

**Временная сложность алгоритма:**
- **Худший случай:** O(n²) - неудачный выбор опорного элемента
- **Средний случай:** O(n log n) - случайный выбор опорного
- **Лучший случай:** O(n log n) - сбалансированное разделение

---

### **7. Пирамидальная сортировка (Heap Sort)**

**Определение:** Алгоритм сортировки, использующий структуру данных "куча" для эффективного извлечения максимальных элементов.

**Объяснение работы алгоритма:**
- Строит из массива max-кучу (бинарное дерево с свойством кучи)
- Последовательно извлекает максимальный элемент (корень)
- Перестраивает кучу после каждого извлечения
- Извлеченные элементы образуют отсортированный массив

**Временная сложность алгоритма:**
- **Худший случай:** O(n log n)
- **Средний случай:** O(n log n)
- **Лучший случай:** O(n log n)
- Всегда гарантированная сложность O(n log n)

---

### **8. Последовательный поиск (Linear Search)**

**Определение:** Простейший алгоритм поиска, проверяющий каждый элемент последовательно до нахождения искомого.

**Объяснение работы алгоритма:**
- Начинает с первого элемента массива
- Последовательно сравнивает каждый элемент с целевым значением
- При нахождении совпадения возвращает индекс элемента
- При отсутствии элемента возвращает -1

**Временная сложность алгоритма:**
- **Худший случай:** O(n) - элемент в конце или отсутствует
- **Средний случай:** O(n) - элемент в середине массива
- **Лучший случай:** O(1) - элемент в начале массива

---

### **9. Бинарный поиск (Binary Search)**

**Определение:** Эффективный алгоритм поиска в отсортированном массиве, многократно делящий область поиска пополам.

**Объяснение работы алгоритма:**
- Определяет границы поиска (начало и конец массива)
- Вычисляет средний элемент текущей области
- Сравнивает средний элемент с искомым значением
- Сужает область поиска в зависимости от результата сравнения
- Повторяет до нахождения элемента или пустой области

**Временная сложность алгоритма:**
- **Худший случай:** O(log n) - элемент отсутствует или на границе
- **Средний случай:** O(log n) - элемент в произвольной позиции
- **Лучший случай:** O(1) - элемент в середине массива

---

### **10. Интерполирующий поиск (Interpolation Search)**

**Определение:** Улучшенный алгоритм поиска для равномерно распределенных данных, предсказывающий позицию элемента на основе значений.

**Объяснение работы алгоритма:**
- Использует формулу интерполяции для предсказания позиции элемента
- Вычисляет вероятное местоположение на основе значений границ и искомого элемента
- Сравнивает элемент в вычисленной позиции с искомым
- Рекурсивно сужает область поиска

**Временная сложность алгоритма:**
- **Худший случай:** O(n) - неравномерное распределение данных
- **Средний случай:** O(log log n) - равномерное распределение
- **Лучший случай:** O(1) - точное предсказание позиции

---

### **11. Поиск по Фибоначчи (Fibonacci Search)**

**Определение:** Алгоритм поиска, использующий числа Фибоначчи для определения точек разделения массива.

**Объяснение работы алгоритма:**
- Использует числа Фибоначчи для определения позиций сравнения
- Делит массив в пропорциях близких к золотому сечению
- Сравнивает элемент в вычисленной позиции с искомым
- Сужает область поиска на основе сравнения
- Использует только операции сложения и вычитания

**Временная сложность алгоритма:**
- **Худший случай:** O(log n) - аналогично бинарному поиску
- **Средний случай:** O(log n) - сбалансированное деление
- **Лучший случай:** O(1) - быстрый успех
